# iOS 提升打包速度

[toc]

## 日常开发

日常开发的优化空间并不大，因为默认情况下 Xcode 会使用上次编译时留下的缓存，也就是所谓的增量编译。因此，日常开发的主要耗时由三部分构成：
> 总耗时 = 增量编译 + 链接 + 生成调试信息（dSYM）

### 增量编译
因为耗时较短（大概十几秒或者更少），几乎不存在优化的空间，但是非常容易恶化。因为只有头文件不变的编译单元才能被缓存，如果某个文件被 N 个文件引用，且这个文件的头文件发生了变化，那么这 N 个文件都会重编译。比如基础库的头文件中使用宏定义，比如定义一些全局都可以读取的常量，比如是否开启调试，服务器的地址等等。

### 链接
链接没有缓存，而且只能用单核进行，因此它的耗时主要取决于单核性能和磁盘读写速度。考虑到我们的目标文件一般都比较小，因此 4K 随机读写的性能应该会更重要一些。

### 调试信息
日常开发时，并不需要生成 `dSYM` 文件，这个文件主要用于崩溃时查找调用栈，方便线上应用进行调试，而开发过程中的崩溃可以直接在 Xcode 中看到，关闭这个功能不会对开发产生任何负面影响。

日常开发的优化空间不大，即使是庞大的项目，落后的机器性能，关闭 `dSYM` 以后也就耗时 30s 左右。相比之下，打包速度可以优化和讨论的地方就比较多了。

## 持续集成
在利用 `Jenkins` 等工具进行持续集成时，缓存不推荐被使用。这是因为苹果的缓存不够稳定，因此，无论是手动删除 `Derived Data` 文件夹，还是调用 `xcodebuild clean` 命令，都会把缓存清空。或者直接使用 `xcodebuild archive`，会自动忽略缓存。每次都要全部重编译是导致打包速度慢的根本原因。

## PCH 
PCH 文件的好处是，这个文件中的头文件只会被编译一次并缓存下来，然后添加到项目中 所有 的头文件中去。但很智障的一点是，所有文件都会隐式的依赖所有 PCH 中的文件，而真正需要被全局依赖的文件其实非常少。PCH 文件一旦发生修改，会导致彻彻底底，完完整整的项目重编译，从而降低编译速度。正是因为 PCH 的副作用甚至抵消了它带来的优化，苹果已经默认不使用 PCH 文件了。
用来取代 PCH 的就是 `Clang modules` 技术，对于开启了这一选项的项目，我们可以用 `@import` 来替代过去的 `#import`，比如: `@import UIKit;` 等价于 `#import <UIKit/UIKit.h>`
抛开自动链接 `framework` 这些小特性不谈，`Clang modules` 可以理解为模块化的 PCH，它具备了 PCH 可以缓存头文件的优点，同时提供了更细粒度的引用。

## 定位瓶颈

首先对 `xcodebuild` 的输出结果进行详细分析。它的输出结果对开发者并不友好，几乎没有可读性， `xcpretty` 这个工具可以格式化它（[xcpretty使用官方文档](https://github.com/supermarin/xcpretty)）

```
sudo gem install xcpretty 
```  

使用 `gnomon` 可以标记出另外一个命令执行消耗的时间信息

```
npm install -g gnomon
```

需要先下载安装或者 `homebrew` 安装 npm

```
brew install node
```
npm 跟着一起安装了，全局安装命令, 安装在 `/usr/local/lib`，需要重新给npm的目录写下权限避免依赖库安装提示以及用sudo
```
sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}
```

### 格式化 xcodebuild
xcodebuild 编译 ---> xcpretty 格式化输出 ---> gnomon 计算时间 ---> 重定向数据到本地TXT ---> sort排序结果

```
xcodebuild -workspace KKProject.xcworkspace -scheme KKProject -archivePath ~/Desktop archive | xcpretty | gnomon -i | grep Compiling >>fileTime.txt
``` 

`-archivePath ~/Desktop archive` 直接忽略缓存

### 对结果进行排序

取前100个
```
sort -r fileTime.txt | head -n 100 | grep Compiling >>new_fileTime.txt
```

排查出编译耗时的操作

## 工程设置

一般来说，我们的持续集成工具主要是用来给产品经理或者测试人员使用，用来体验功能或者验证 Bug，然而在手机上使用的 Release 模式，默认会开启各种优化，这些优化都是牺牲编译性能，因此，加速打包的思路和优化的思路是互逆的，我们要做的就是关闭一些优化。这里推荐一篇文章：[关于Xcode编译性能优化的研究工作总结](http://blog.csdn.net/qq_25131687/article/details/52194034)可以说相当全面了。

### 仅支持 armv7 指令集
默认情况下我们打出来的包会有 armv7 和 arm64 两种指令集， 前者负责兜底，而对于支持 arm64 指令集的机型来说，使用最新的指令集可以获得更好的性能。当然代价就是生成两种指令集花费了更多时间。所以在急速打包模式下，我们只生成 armv7 这种最老的指令集，牺牲了运行时性能换取编译速度。

### 关闭编译优化
优化的基本原理是牺牲编译时性能，追求运行时性能。常见的优化有编译时删除无用代码，保留调试信息，函数内联等等。最主要的优化是把 Optimize level 改成 O0，表示不做任何优化。

### 使用虚拟磁盘
编译过程中需要大量的磁盘 IO，这主要发生在 Derived Data 目录下，因此如果内存足够，可以考虑划出 4G 左右的内存，建一个虚拟磁盘，这样将会把磁盘 IO 优化为 内存 IO，从而提高速度。由于打包机器每次都会重编译，因此并不需要担心重启机器后缓存丢失的问题。

### 不生成 dYSM 文件
一般来说 只要精简指令集并关闭优化即可，有条件的机器可以使用虚拟磁盘，不建议再做其它修改。

### 二进制化
二进制化主要指的是利静态库代替源码，避免编译。

### 硬件加速
编译是一个考验多核性能的操作，因此在一定范围内（比如 10 核以内），提升 CPU 核数远比提升单核主频对编译速度的影响大。








